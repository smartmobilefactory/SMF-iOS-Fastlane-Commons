
@fastlane_commons_dir_path = File.expand_path(File.dirname(__FILE__))
@should_commons_repo_be_downloaded = (File.exist?("#{@fastlane_commons_dir_path}/flow") == false || File.exist?("#{@fastlane_commons_dir_path}/steps") == false)

#################
### Lifecycle ###
#################

before_all do

  # Load the Fastlane config from the disk into memory
  smf_load_fastlane_config

  # Clone the Commons Repo
  if @should_commons_repo_be_downloaded
    UI.message("Downloading Fastlane Commons Repo as it's not locally available yet")
    @fastlane_commons_dir_path = "#{smf_workspace_dir}/.fastlane-smf-commons"
    smf_remove_fastlane_commons_repo
    smf_clone_fastlane_commons_repo
  else
    UI.message("The Fastlane Commons Repo won't be downloaded as it's already available locally")
  end

  # Import the splitted Fastlane classes
  import_all "#{@fastlane_commons_dir_path}/flow"
  import_all "#{@fastlane_commons_dir_path}/steps"
  import_all "#{@fastlane_commons_dir_path}/utils"
end

desc "Called on success"
after_all do
  if @should_commons_repo_be_downloaded
    smf_remove_fastlane_commons_repo
  end
end

desc "Called on error"
error do |lane, exception|
  if @smf_set_should_send_deploy_notifications == true
    smf_handle_exception(
      exception: exception,
      )
  end

  if @should_commons_repo_be_downloaded
    smf_remove_fastlane_commons_repo
  end
end

##############
### Helper ###
##############

def import_all(path)
  Dir["#{path}/*.rb"].each { |file| 
    import file 
  }
end

##############
### Config ###
##############

def smf_value_for_keypath_in_hash_map(hash_map, keypath)
  keys = keypath.split("/")
  value = hash_map
  for key in keys
    if value.key?(key.to_sym)
      value = value[key.to_sym]
    else
      raise "Error: Couldn't find keypath \"#{keypath}\" in \"#{hash_map}\"".red
    end
  end
  return value
end

def smf_load_fastlane_config
  config_path = fastlane_config_path
  UI.message("Reading the SMF Fastlane config from \"#{config_path}\"")
  config_file = File.read(config_path)
  if config_file
    @smf_fastlane_config ||= JSON.parse(config_file, :symbolize_names => true)
    UI.success("Parsed config file into the hash map")
  else
    raise "Error: The SMF Fastlane config file doesn't exist at path \"#{config_path}\"".red
  end
end

def smf_set_should_send_deploy_notifications(should_notify)
  @smf_set_should_send_deploy_notifications = should_notify
end

def smf_set_build_variant(build_variant, reset_build_variant_array = true)
  @smf_build_variant = build_variant.downcase
  @smf_build_variant_sym = @smf_build_variant.to_sym
  if reset_build_variant_array
    smf_set_build_variants_array(nil)
  end
end

def smf_set_build_variants_array(build_variants)
  @smf_build_variants_array = build_variants
end

def smf_set_build_variants_matching_regex(regex)
  all_build_variants = @smf_fastlane_config[:build_variants].keys
  matching_build_variants = all_build_variants.grep(/#{regex}/)
  
  UI.important("Found matching build variatns: #{matching_build_variants}")
  
  smf_set_build_variants_array(matching_build_variants)
end

def smf_set_bump_type(bump_type)
  @smf_bump_type = bump_type
end

def smf_set_git_branch(branch)
  @smf_git_branch = branch
end

####################
### Commons Repo ###
####################

private_lane :smf_clone_fastlane_commons_repo do
  fastlane_commons_branch = @smf_fastlane_config[:project][:fastlane_commons_branch]
  sh "git clone -b \"" + fastlane_commons_branch + "\" git@github.com:smartmobilefactory/SMF-iOS-Fastlane-Commons.git #{@fastlane_commons_dir_path}"
end

private_lane :smf_remove_fastlane_commons_repo do
  sh "if [ -d #{@fastlane_commons_dir_path} ]; then rm -rf #{@fastlane_commons_dir_path}; fi"
end

##############
### Helper ###
##############

def smf_workspace_dir
  if smf_is_jenkins_environment
    return ENV[$WORKSPACE_ENV_KEY]
  else
    path = "#{Dir.pwd}"
    if path.end_with?("/fastlane")
      path = path.chomp("/fastlane") 
    end
    UI.message("Fastlane doesn't seem to run in a Jenkins environement. The workspace path is \"#{path}\"")
    return path
  end
end
