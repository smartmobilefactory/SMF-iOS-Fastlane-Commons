require 'uri'

before_all do
  # due to a wrong commit in fastlane 2.43.0 we disable temporary the update
  #update_fastlane
end

######################
### smf_deploy_app ###
######################

desc "Builds the project including build number incrementation, MetaJSON etc. and uploads the version to Hockey."
private_lane :smf_deploy_app do |options|

  UI.important("Deplay a new app version")

  # Read options parameter
  build_variant = options[:build_variant].downcase
  build_variants_config = options[:build_variants_config]
  branch = options[:branch]
  generateMetaJSON = options[:generateMetaJSON]
  use_sigh = (options[:use_sigh].nil? ? true : options[:use_sigh])
  use_hockey = (options[:use_hockey].nil? ? true : options[:use_hockey])
  project_config = build_variants_config["project"]
  build_variant_config = build_variants_config["targets"][build_variant]

  # check if the next Tag exist
  smf_check_tag(
    project_config: project_config,
    build_variant: build_variant
    )

  # Increment the build number
  smf_increment_build_number(
    project_config: project_config
    )

  # Build and archive the IPA
  smf_archive_ipa(
    project_config: project_config,
    build_variant: build_variant,
    build_variants_config: build_variants_config,
    use_sigh: use_sigh
    )

  # Commit and push generated code. There can be changes eg. from PhraseApp + R.swift
  smf_push_generated_code(
    branch: branch
    )

  # Push the build number
  smf_push_build_number(
    project_config: project_config,
    branch: branch
    )

  # Collect the changelog 
  smf_collect_changelog(
    build_variant: build_variant,
    project_config: project_config
    )

  # Push the build number
  smf_add_git_tag(
    project_config: project_config,
    branch: branch,
    tag_prefix: "build/#{build_variant}_b"
    )

  # Update the MetaJSONS if wanted
  if generateMetaJSON != false
    smf_generate_meta_json(
      project_config: project_config,
      build_variant: build_variant,
      branch: branch,
      build_variants_contains_whitelist: ["alpha"]
      )
  end

  # Upload Ipa to Testflight and Download the generated DSYM
  if build_variant_config["upload_itc"] == true

    smf_upload_ipa_to_testflight(
      build_variant_config: build_variant_config
      )

    smf_download_dsym_from_testflight(
      project_config: project_config,
      build_variant_config: build_variant_config
      )

    smf_itunes_precheck(
      project_config: project_config,
      build_variant_config: build_variant_config
      )
  end

  if use_hockey
  # Upload the IPA to HockeyApp
  smf_upload_ipa_to_hockey(
    build_variant_config: build_variant_config,
    project_config: project_config
    )

  # Disable the former HockeyApp entry
  smf_disable_former_hockey_entry(
    build_variant: build_variant,
    build_variant_config: build_variant_config,
    build_variants_contains_whitelist: ["beta"]
    )
  end

end


#######################
### smf_publish_pod ###
#######################

# options: branch (String), tag_prefix (String) [optional], bump_type (String), podspec_path (String), repository_path (String), specs_repo (String)

desc "Publish the pod. Either to the official specs repo or to the SMF specs repo"
private_lane :smf_publish_pod do |options|

  UI.important("Publish Pod")

  # Read options parameter
  framework_config = options[:framework_config]
  project_config = options[:project_config]
  branch = options[:branch]
  generateMetaJSON = options[:generateMetaJSON]
  tag_prefix = (options[:tag_prefix].nil? ? "" : options[:tag_prefix])
  bump_type = options[:bump_type]
  podspec_path = framework_config["podsepc_path"]
  repository_path = project_config["github_repo_path"]
  specs_repo = framework_config["pods_specs_repo"]


  # Unlock keycahin to enable pull repo with https
  unlock_keychain(path: "login.keychain", password: ENV["LOGIN"])

  unlock_keychain(path: "jenkins.keychain", password: ENV["JENKINS"])

  # Make sure the repo is up to date and clean
  ensure_git_branch(branch: branch)
  ensure_git_status_clean

  # Update the CocoaPods repo to avoid unknown Pod version issues
  sh "pod repo update"

  # Bump the pods version if needed
  if bump_type != "current"
    version_bump_podspec(
      path: podspec_path,
      bump_type: bump_type
      )
  end

  version = read_podspec(path: podspec_path)["version"]

  # Commit the  version bump if needed
  if bump_type != "current"
    git_commit(
      path: podspec_path,
      message: "Release Pod #{version}"
      )
  end

  smf_collect_changelog(
    build_variant: bump_type,
    project_config: project_config,
    tag_prefix: tag_prefix
    )

  # Add the git tag
  add_git_tag(tag: "#{tag_prefix}#{version}")
  push_to_git_remote
  
  # Publish the pod. Either to a private specs repo or to the offical one
  if specs_repo
    pod_push(
      repo: specs_repo,
      path: podspec_path,
      allow_warnings: true
      )
  else
    pod_push(path: podspec_path)
  end

  github_release = set_github_release(
    repository_name: repository_path,
    api_token: ENV['GITHUB_TOKEN'],
    name: version,
    tag_name: "#{tag_prefix}#{version}",
    description: ENV["SMF_CHANGELOG"],
    commitish: branch
    )

  # Update the MetaJSONS if wanted
  if generateMetaJSON != false
    smf_generate_meta_json(
      project_config: project_config,
      build_variant: bump_type,
      branch: branch,
      build_variants_contains_whitelist: ["patch", "minor", "major", "current"]
      )
  end

end


##########################
### smf_handle_success ###
##########################

# options: build_variant (String), project_config (Hash), release_title (String) [optional], app_link (String) [optional] [default: HockeyApp Link]

desc "Handle the success by sending email to the authors and post to the hipchat channel"
private_lane :smf_handle_success do |options|

  UI.important("Handle the build job success")

  # Read options parameter
  build_variant = options[:build_variant].downcase
  project_config = options[:project_config]
  release_title = (options[:release_title].nil? ? "#{project_config["project_name"]} #{build_variant.upcase} (Build #{get_build_number})" : options[:release_title])
  hipchat_channel = project_config["hipchat_channel"]
  app_link = (options[:app_link].nil? ? Actions.lane_context[Actions::SharedValues::HOCKEY_DOWNLOAD_LINK] : options[:app_link])

  if ENV["SMF_CHANGELOG"].nil?
    # Collect the changelog (again) in case the build job failed before the former changelog collecting
    smf_collect_changelog(
      build_variant: build_variant,
      project_config: project_config
      )
  end

  smf_notify_via_mail(
    build_variant: build_variant,
    release_title: release_title,
    send_to_autors: true,
    success: true,
    app_link: app_link
    )

  if hipchat_channel
    hipchat_channel = URI.escape(hipchat_channel)
    smf_notify_via_hipchat(
      build_variant: build_variant,
      release_title: release_title,
      project_config: project_config,
      hipchat_channel: hipchat_channel,
      success: true
      )
  end
end

######################################
### smf_handle_pod_publish_success ###
######################################

# options: build_variant (String), project_config (Hash), framework_config (Hash), release_title (String) [optional]

desc "Handle the success by sending email to the authors and post to the hipchat channel"
private_lane :smf_handle_pod_publish_success do |options|

  # Read options parameter
  build_variant = options[:build_variant].downcase
  project_config = options[:project_config]
  framework_config = options[:framework_config]

  current_version = read_podspec(path: framework_config["podsepc_path"])["version"]
  release_title = (options[:release_title].nil? ? "#{project_config["project_name"]} #{current_version}" : options[:release_title])

  smf_handle_success(
    build_variant: build_variant,
    release_title: release_title,
    project_config: project_config,
    app_link: ""
    )
end


############################
### smf_handle_exception ###
############################

# options: exception (exception), build_variant (String), project_config (Hash), release_title (String) [optional]

desc "Handle the exception by sending email to the authors"
private_lane :smf_handle_exception do |options|

  UI.important("Handle the build job exception")

  # Read options parameter
  exception = options[:exception]
  build_variant = options[:build_variant].downcase
  project_config = options[:project_config]
  hipchat_channel = project_config["hipchat_channel"]
  release_title = (options[:release_title].nil? ? "#{project_config["project_name"]} #{build_variant.upcase} (Build #{get_build_number})" : options[:release_title])

  if ENV["SMF_CHANGELOG"].nil?
    # Collect the changelog (again) in case the build job failed before the former changelog collecting
    smf_collect_changelog(
      build_variant: build_variant,
      project_config: project_config
      )
  end

  smf_notify_via_mail(
    build_variant: build_variant,
    release_title: release_title,
    send_to_autors: true,
    success: false,
    exception_message: exception,
    app_link: ""
    )

    if hipchat_channel
    hipchat_channel = URI.escape(hipchat_channel)

    smf_notify_via_hipchat(
      build_variant: build_variant,
      release_title: release_title,
      project_config: project_config,
      hipchat_channel: hipchat_channel,
      success: false,
      exception_message: exception,
      )
    end
end


########################################
### smf_handle_pod_publish_exception ###
########################################

# options: build_variant (String), project_config (Hash), framework_config (Hash), exception (Exception), release_title (String) [optional]

desc "Handle the success by sending email to the authors and post to the hipchat channel"
private_lane :smf_handle_pod_publish_exception do |options|

  # Read options parameter
  build_variant = options[:build_variant].downcase
  project_config = options[:project_config]
  framework_config = options[:framework_config]
  exception = options[:exception]

  current_version = read_podspec(path: framework_config["podsepc_path"])["version"]
  release_title = (options[:release_title].nil? ? "#{project_config["project_name"]} #{current_version}" : options[:release_title])

  smf_handle_exception(
    build_variant: build_variant,
    release_title: release_title,
    project_config: project_config,
    exception: exception,
    )
end


#######################
### smf_archive_ipa ###
#######################

# options: build_variants_config (Hash), project_config (Hash), build_variant (String)

desc "Build the project based on the build type."
private_lane :smf_archive_ipa do |options|

  UI.important("Build a new version")

  # Read options parameter
  project_name = options[:project_config]["project_name"]
  build_variant = options[:build_variant].downcase
  build_variant_config = options[:build_variants_config]["targets"][build_variant]
  use_sigh = (options[:use_sigh].nil? ? true : options[:use_sigh])

  extensions_suffixes = options[:build_variants_config]["extensions_suffixes"]


  # Set the Apple Team ID
  team_id build_variant_config["team_id"]

  if use_sigh
    unlock_keychain(path: "login.keychain", password: ENV["LOGIN"])

    is_adhoc_build = build_variant.include? "adhoc"

    sigh(
      adhoc: is_adhoc_build,
      skip_certificate_verification:true,
      app_identifier: build_variant_config["bundle_identifier"]
      )

    if extensions_suffixes
      for extension_suffix in extensions_suffixes do
        
        begin
          sigh(
            adhoc: is_adhoc_build,
            skip_certificate_verification:true,
            app_identifier: "#{build_variant_config["bundle_identifier"]}.#{extension_suffix}"
            )
        rescue
          UI.important("Seems like #{build_variant_config["bundle_identifier"]}.#{extension_suffix} is not yet included in this project! Skipping sigh!")
          next   
        end

      end
    end
  end

  unlock_keychain(path: "jenkins.keychain", password: ENV["JENKINS"])

  gym(
    clean: true,
    workspace: "#{project_name}.xcworkspace",
    scheme: build_variant_config["scheme"],
    configuration: 'Release',
    codesigning_identity: build_variant_config["code_signing_identity"],
    output_directory: "build",
    archive_path:"build/",
    output_name: build_variant_config["scheme"],
    include_symbols: true,
    include_bitcode: true
    )
end

#############################
### smf_collect_changelog ###
#############################

# options: build_variant (String)

desc "Collect git commit messages and author mail adresses into a changelog and store them as environmental varibles."
private_lane :smf_collect_changelog do |options|

  UI.important("collect commits back to the last tag")

  # Read options parameter
  build_variant = options[:build_variant].downcase
  project_platform = options[:project_config]["platform"]

  matching_pattern = (options[:tag_prefix].nil? ? "#{build_variant}" : options[:tag_prefix])

  NO_GIT_TAG_FAILURE = "NO_GIT_TAG_FAILURE"

  # Get last tag for the current branch
  last_tag = sh("git describe --tags --match \"*#{matching_pattern}*\" --abbrev=0 HEAD --first-parent || echo #{NO_GIT_TAG_FAILURE}").to_s

  # Use the initial commit if there is no matching tag yet
  if last_tag.include? NO_GIT_TAG_FAILURE
    last_tag = sh("git rev-list --max-parents=0 HEAD").to_s
  end

  last_tag = last_tag.strip

  if ["patch", "minor", "major", "current"].any? { |item| build_variant.downcase.include?(item) }
    ENV["SMF_CHANGELOG"] =  changelog_from_git_commits(between:[last_tag,"HEAD"],include_merges: false, pretty: '- (%an) %s')
    ENV["SMF_CHANGELOG_EMAILS"] = changelog_from_git_commits(between:[last_tag,"HEAD"],include_merges: false, pretty: '%ae')
  else
    ENV["SMF_CHANGELOG"] =  changelog_from_git_commits(between:[last_tag,"HEAD"],include_merges: false, pretty: '- (%an) %s')
    ENV["SMF_CHANGELOG_EMAILS"] = changelog_from_git_commits(between:[last_tag,"HEAD"],include_merges: false, pretty: '%ae')
  end

  if (!project_platform.nil?) && (project_platform.eql? "mac")

   File.open("changelog.properties", 'w') { |file| file.write("SMF_CHANGELOG='#{ENV["SMF_CHANGELOG"]}'") }
   File.open("emails.properties", 'w') { |file| file.write("SMF_CHANGELOG_EMAILS='#{ENV["SMF_CHANGELOG_EMAILS"]}'") }

  end

end

#############################
#####   smf_check_tag   #####
#############################

# options: build_variant (String)

desc "Check if the tag exist after incrementation of the build number"
private_lane :smf_check_tag do |options|

  UI.important("check if the Incremented Tag exist")

  # Read options parameter
  build_variant = options[:build_variant].downcase
  project_name = options[:project_config]["project_name"]

  tag_prefix = (options[:tag_prefix].nil? ? "build/#{build_variant}_b" : options[:tag_prefix])
  tag_suffix = (options[:tag_suffix].nil? ? "" : options[:tag_suffix])

  version = get_build_number(xcodeproj: "#{project_name}.xcodeproj")
  version_string = get_incremented_build_number(version)

  if git_tag_exists(tag: tag_prefix+version_string.to_s+tag_suffix)
    raise "Git tag already existed".red
  end

end


#######################
### smf_add_git_tag ###
#######################

# options: project_config (Hash), tag_prefix (String), tag_suffix (String) [optional], branch (String) [optional]

desc "Tag the current git commit."
private_lane :smf_add_git_tag do |options|

  # Read options parameter
  project_name = options[:project_config]["project_name"]
  tag_prefix = (options[:tag_prefix].nil? ? "" : options[:tag_prefix])
  tag_suffix = (options[:tag_suffix].nil? ? "" : options[:tag_suffix])
  branch = options[:branch]

  UI.important("Tag the current commit")
  version = get_build_number(xcodeproj: "#{project_name}.xcodeproj")
  version = version.to_s

  # Tag the current commit
  if git_tag_exists(tag: tag_prefix+version+tag_suffix)
    UI.message("Git tag already existed")
  else
    add_git_tag(
      tag: tag_prefix+version+tag_suffix
      )
  end
  
  push_to_git_remote(
    remote: 'origin',
    local_branch: branch,
    remote_branch: branch,
    force: false,
    tags: true
    )

end



############################
### smf_test_pod_project ###
############################

# options: project_config (Hash), framework_config (Hash)

desc "Performs the unit tests of a project."
private_lane :smf_test_pod_project do |options|

  UI.important("Perform the unit tests")

  # Read options parameter
  project_config = options[:project_config]
  framework_config = options[:framework_config]

  scan(
    workspace: "#{project_config["project_name"]}.xcworkspace",
    scheme: "#{framework_config["scheme"]}",
    clean: false,
    output_files: "report.xml"
    )

end

#######################################
### smf_disable_former_hockey_entry ###
#######################################

# options: build_variant_config (Hash), build_variant (String)

desc "Disable the downlaod of the former app version on HockeyApp - does not apply for Alpha builds."
private_lane :smf_disable_former_hockey_entry do |options|

  # Read options parameter
  build_variant = options[:build_variant].downcase
  build_variant_config = options[:build_variant_config]
  build_variants_contains_whitelist = options[:build_variants_contains_whitelist]

  # Disable the download of the former non Alpha app on Hockey App
  if (!build_variants_contains_whitelist) || (build_variants_contains_whitelist.any? { |whitelist_item| build_variant.include?(whitelist_item) })
    if (Actions.lane_context[Actions::SharedValues::HOCKEY_BUILD_INFORMATION]['id'] > 1)
      previous_version_id  = Actions.lane_context[Actions::SharedValues::HOCKEY_BUILD_INFORMATION]['id'] - 1

      UI.important("HERE IS THE ID OF THE Current VERSION #{Actions.lane_context[Actions::SharedValues::HOCKEY_BUILD_INFORMATION]['id']}")
      UI.important("HERE IS THE ID OF THE Previous VERSION #{previous_version_id}")

      disable_hockey_download(
        api_token: ENV["HOCKEYAPP_API_TOKEN"],
        public_identifier: build_variant_config["hockeyapp_id"],
        version_id: "#{previous_version_id}"
        )
    end
  end
end


##############################
### smf_generate_meta_json ###
##############################

# options: branch (String), build_variant (String) and build_variants_contains_whitelist (String) [optional]

desc "Create and push the metaJSON files - applys only for Alpha builds."
private_lane :smf_generate_meta_json do |options|

  # Read options parameter
  branch = options[:branch]
  build_variant = options[:build_variant].downcase
  project_name = options[:project_config]["project_name"]
  build_variants_contains_whitelist = options[:build_variants_contains_whitelist]

  if (!build_variants_contains_whitelist) || (build_variants_contains_whitelist.any? { |whitelist_item| build_variant.include?(whitelist_item) })
    desc "Create the meta JSON files"
    # Fetch the MetaJSON scripts repo
    sh "git clone git@github.com:smartmobilefactory/SMF-iOS-MetaJSON.git"
    # Create and commit the MetaJSON files
    sh "cd .. && fastlane/SMF-iOS-MetaJSON/scripts/update-and-push-meta-jsons.sh \"#{branch}\" \"#{project_name}\" || true"
    # Remove the MetaJSON scripts repo
    sh "rm -rf SMF-iOS-MetaJSON"
  end

end


###############################
### smf_push_generated_code ###
###############################

# options: branch (String)

desc "Commit and push generated code"
private_lane :smf_push_generated_code do |options|

  UI.important("Commit and push generated code")
    # Read options parameter
    branch = options[:branch]

    sh "git add ../Generated/ || true"
    sh "git commit -m \"Update generated code\" || true"

    push_to_git_remote(
      remote: 'origin',
      local_branch: branch,
      remote_branch: branch,
      force: false,
      tags: false
      )

  end


#############################
### smf_push_build_number ###
#############################

# options: project_config (Hash), branch (String)

desc "Commit and push the build number."
private_lane :smf_push_build_number do |options|

  # Read options parameter
  project_name = options[:project_config]["project_name"]
  branch = options[:branch]

  UI.important("Increment Build Version Code")
  version = get_build_number(xcodeproj: "#{project_name}.xcodeproj")
  puts version

  commit_version_bump(
    xcodeproj: "#{project_name}.xcodeproj",
    message: "Increment build number to #{version}",
    force: true
    )
  
  push_to_git_remote(
    remote: 'origin',
    local_branch: branch,
    remote_branch: branch,
    force: false,
    tags: false
    )

end

##############################
### smf_notify_via_hipchat ###
##############################

# options: project_config (Hash), release_title (String), channel (String)

desc "Post to a HipChat room if the build was successful"
private_lane :smf_notify_via_hipchat do |options|

  # Read options parameter
  project_name = options[:project_config]["project_name"]
  release_title = options[:release_title]
  hipchat_channel = options[:hipchat_channel]
  exception_message = options[:exception_message]
  success = options[:success]


  case success
  when true
    message = "<table><tr><td><strong>🎉 Successfully released #{release_title} 🎉</strong></td></tr><tr></tr><tr><td><pre>#{ENV["SMF_CHANGELOG"][0..9000]}#{'\\n...' if ENV["SMF_CHANGELOG"].length > 9000}</pre></td></tr></table>"
  else
    message = "<table><tr><td><strong>❌ Failed to build and release #{release_title} ❌ 😢</strong></td></tr><tr></tr><tr><td><pre>#{ENV["SMF_CHANGELOG"][0..9000]}#{'\\n...' if ENV["SMF_CHANGELOG"].length > 9000}</pre></td></tr><tr><td><strong> CI build: </strong><a href=#{ENV["BUILD_URL"]}> Build </a></td></tr></table>"

  end
  hipchat(
    message: message,
    channel: hipchat_channel,
    success: true,
    api_token: ENV["HIPCHAT_API_TOKEN"],
    notify_room: true,
    version: "2",
    message_format: "html",
    include_html_header: false,
    from: "#{project_name} iOS CI"
    )

end


###########################
### smf_notify_via_mail ###
###########################

# options: release_title (String), authors_emails (String), success (Boolean), exception_message (String) [Optional], app_link (String)

desc "Send emails to all collaborators who worked on the project since the last build to inform about successfully or failing build jobs."
private_lane :smf_notify_via_mail do |options|

  # Read options parameter
  release_title = options[:release_title]
  send_to_autors = options[:send_to_autors]
  success = options[:success]
  exception_message = options[:exception_message]
  app_link = options[:app_link]

  authors_emails = []
  if (send_to_autors) && (ENV["SMF_CHANGELOG_EMAILS"])
    authors_emails = ENV["SMF_CHANGELOG_EMAILS"].split(" ").uniq.delete_if{|e| e == "git-checkout@smartmobilefactory.com"}
  end

  case success
  when true
    subject = "Successfully released #{release_title}"
    message = "🎉 #{release_title} is available 🎉"
  else
    subject = "Failed to build #{release_title}"
    message = "😢 Failed to build and release #{release_title} 😢"
    message << "<p style='
    border: 1px solid #D8D8D8;
    padding: 5px;
    border-radius: 5px;
    font-family: Arial;
    font-size: 11px;
    text-transform: uppercase;
    background-color: rgb(255, 249, 242);
    color: rgb(211, 0, 0);
    text-align: center;' >#{exception_message} <p>"
  end

  authors_emails.each do |receiver|
    mailgun(
      subject: subject,
      postmaster:"postmaster@mailgun.smfhq.com",
      apikey: ENV["MAILGUN_KEY"],
      to: receiver,
      success: success,
      message: message,
      app_link: app_link,
      ci_build_link: ENV["BUILD_URL"],
      template_path: "/Users/smf/jenkins/template_mail_ios.erb"
      )
  end

end


################################
### smf_upload_ipa_to_hockey ###
################################

# options: project_config (Hash)

desc "Clean, build and release the app on HockeyApp"
private_lane :smf_upload_ipa_to_hockey do |options|

  UI.important("Upload a new build to HockeyApp")

  # Read options parameter
  project_name = options[:project_config]["project_name"]
  hockey_app_id = options[:build_variant_config]["hockeyapp_id"]
  bundle_identifier = options[:build_variant_config]["bundle_identifier"]
  version_number = get_version_number(xcodeproj: "#{project_name}.xcodeproj")
  build_number = get_build_number(xcodeproj: "#{project_name}.xcodeproj")
  scheme = options[:build_variant_config]["scheme"]

  release_notes = message = "#{ENV["SMF_CHANGELOG"][0..4995]}#{'\\n...' if ENV["SMF_CHANGELOG"].length > 4995}"

  #DSYM Path
  path = Pathname.getwd.dirname.to_s + "/#{bundle_identifier}-#{version_number}-#{build_number}.dSYM.zip"
  
  NO_APP_FAILURE = "NO_APP_FAILURE"
  sh "cd ../build; zip -r9 #{scheme}.app.zip #{scheme}.app || echo #{NO_APP_FAILURE}"
  app_path = Pathname.getwd.dirname.to_s + "/build/#{scheme}.app.zip"
  puts app_path


  hockey(
    api_token: ENV["HOCKEYAPP_API_TOKEN"],
    ipa: File.exist?(app_path) ? app_path : lane_context[SharedValues::IPA_OUTPUT_PATH], 
    notify: "0",
    notes: release_notes,
    public_identifier: hockey_app_id,
    dsym: File.exist?(path) ? path : nil  
  )

end

####################################
### smf_upload_ipa_to_testflight ###
####################################

# options: build_variant_config (Hash)

desc "upload the app on Testflight"
private_lane :smf_upload_ipa_to_testflight do |options|

  UI.important("Upload a new build to Testflight")
  username = options[:build_variant_config]["itc_apple_id"]

  pilot(
    username: username.nil? ? nil : username,
    skip_submission:false
    )

end

desc "Clean, build and release the app on HockeyApp"
private_lane :smf_download_dsym_from_testflight do |options|

  UI.important("Download dsym from Testflight")

  project_name = options[:project_config]["project_name"]
  bundle_identifier = options[:build_variant_config]["bundle_identifier"]
  username = options[:build_variant_config]["itc_apple_id"]

  build_number = get_build_number(xcodeproj: "#{project_name}.xcodeproj")
  build_number = build_number.to_s

  download_dsyms(username: username, app_identifier: bundle_identifier,  build_number: build_number)

end


################################
### smf_increment_build_number ###
################################

desc "increment build number"
private_lane :smf_increment_build_number do |options|

  UI.important("increment build number")

  project_name = options[:project_config]["project_name"]
  version = get_build_number(xcodeproj: "#{project_name}.xcodeproj")

    increment_build_number(build_number: get_incremented_build_number(version))

end

################################
###   smf_itunes_precheck    ###
################################

private_lane :smf_itunes_precheck do |options|

  project_config = options[:project_config]
  project_name = project_config["project_name"]
  hipchat_channel = project_config["hipchat_channel"]
  build_variant_config = options[:build_variant_config]
  app_identifier = build_variant_config["bundle_identifier"]
  username = build_variant_config["itc_apple_id"]


  begin
   precheck(username: username.nil? ? nil : username , app_identifier: app_identifier)

 rescue => e 
  UI.error "Error while checking Metadata ...:
  #{e.message}"
  subject = "Found Metadata issues for #{project_name}"
  message = "❌<strong> iTunes Precheck failed for #{project_name}</strong> ❌ 😢"
  message << "<p style='
  border: 1px solid #D8D8D8;
  padding: 5px;
  border-radius: 5px;
  font-family: Arial;
  font-size: 11px;
  text-transform: uppercase;
  background-color: rgb(255, 249, 242);
  color: rgb(211, 0, 0);
  text-align: center;' >#{e.message[0..8000]}#{'\\n...' if e.message.length > 8000}<p>
  <strong> CI build: </strong><a href=#{ENV["BUILD_URL"]}> Build </a>"

  mailgun(
    subject: subject,
    postmaster:"postmaster@mailgun.smfhq.com",
    apikey: ENV["MAILGUN_KEY"],
    to: "development@smfhq.com",
    success: false,
    message: message,
    app_link: "",
    ci_build_link: ENV["BUILD_URL"],
    template_path: "/Users/smf/jenkins/template_mail_ios_precheck.erb"
    )

  if hipchat_channel
    hipchat_channel = URI.escape(hipchat_channel)

    hipchat(
      message: message,
      channel: hipchat_channel,
      success: false,
      api_token: ENV["HIPCHAT_API_TOKEN"],
      notify_room: true,
      version: "2",
      message_format: "html",
      include_html_header: false,
      from: "#{project_name} iOS CI"
      )
  end
end
end

##########################################################
###   check build number whether it's a int or float   ###
##########################################################
def get_incremented_build_number(version)

  if version.to_s.include? "."
    
   parts = version.to_s.split(".")
   count = parts.count

   incremented_version = parts[count - 1].to_i + 1

   version_string = ""

    for i in 0..count-2
     version_string += parts[i].to_s + "."
    end

   version_string += incremented_version.to_s

  else 
   version_string = version.to_i + 1

  end    

 return version_string.to_s

end
