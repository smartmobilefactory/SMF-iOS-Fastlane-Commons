require 'uri'

######################
### smf_deploy_app ###
######################

desc "Builds the project including build number incrementation, MetaJSON etc. and uploads the version to Hockey."
private_lane :smf_deploy_app do |options|

  UI.important("Deplay a new app version")

  # Read options parameter
  build_variant = options[:build_variant].downcase
  build_variants_config = options[:build_variants_config]
  branch = options[:branch]
  generateMetaJSON = options[:generateMetaJSON]
  project_config = build_variants_config["project"]
  extensions_suffixes = build_variants_config["extensions_suffixes"]
  build_variant_config = build_variants_config["targets"][build_variant]

  # Increment the build number
  increment_build_number

  # Build and archive the IPA
  smf_archive_ipa(
    project_config: project_config,
    build_variant: build_variant,
    build_variants_config: build_variants_config,
    extensions_suffixes: extensions_suffixes
    )

  # Commit and push generated code. There can be chages eg. from PhraseApp + R.swift
  smf_push_generated_code(
    branch: branch
    )

  # Push the build number
  smf_push_build_number(
    project_config: project_config,
    branch: branch
    )

  # Collect the changelog 
  smf_collect_changelog(
    build_variant: build_variant
    )

  # Push the build number
  smf_add_git_tag(
    project_config: project_config,
    branch: branch,
    tag_prefix: "build/#{build_variant}_b"
    )

  # Update the MetaJSONS if wanted
  if generateMetaJSON != false
    smf_generate_meta_json(
      project_config: project_config,
      build_variant: build_variant,
      branch: branch,
      build_variants_contains_whitelist: ["alpha"]
      )
  end

  # Upload the IPA to HockeyApp
  smf_upload_ipa_to_hockey(
    build_variant_config: build_variant_config
    )

  # Disable the former HockeyApp entry
  smf_disable_former_hockey_entry(
    build_variant: build_variant,
    build_variant_config: build_variant_config,
    build_variants_contains_whitelist: ["beta"]
    )
end


#######################
### smf_publish_pod ###
#######################

# options: branch (String), tag_prefix (String) [optional], bump_type (String), podspec_path (String), repository_path (String), specs_repo (String)

desc "Publish the pod. Either to the official specs repo or to the SMF specs repo"
private_lane :smf_publish_pod do |options|

  UI.important("Publish Pod")

  # Read options parameter
  branch = options[:branch]
  tag_prefix = (options[:tag_prefix].nil? ? "" : options[:tag_prefix])
  bump_type = options[:bump_type]
  podspec_path = options[:podspec_path]
  repository_path = options[:repository_path]
  specs_repo = options[:specs_repo]

  # Make sure the repo is up to date and clean
  ensure_git_branch(branch: branch)
  ensure_git_status_clean

  # Update the CocoaPods repo to avoid unknown Pod version issues
  sh "pod repo update"

  # Bump the pods version if needed
  if bump_type != "current"
    version_bump_podspec(
      path: podspec_path,
      bump_type: bump_type
      )
  end

  version = read_podspec(path: podspec_path)["version"]

  # Commit the  version bump if needed
  if bump_type != "current"
    git_commit(
      path: podspec_path,
      message: "Release Pod #{version}"
      )
  end

  # Add the git tag
  add_git_tag(tag: "#{tag_prefix}#{version}")
  push_to_git_remote
  
  # Publish the pod. Either to a private specs repo or to the offical one
  if specs_repo
    pod_push(
      repo: specs_repo,
      path: podspec_path,
      allow_warnings: true
      )
  else
    pod_push(path: podspec_path)
  end

  smf_collect_changelog(
    build_variant: bump_type
    )

  github_release = set_github_release(
    repository_name: repository_path,
    api_token: ENV['GITHUB_TOKEN'],
    name: version,
    tag_name: "#{tag_prefix}#{version}",
    description: ENV["SMF_CHANGELOG"],
    commitish: branch
  )

end


##########################
### smf_handle_success ###
##########################

# options: build_variant (String), project_config (Hash), release_title (String) [optional]

desc "Handle the success by sending email to the authors and post to the hipchat channel"
private_lane :smf_handle_success do |options|

  UI.important("Handle the build job success")

  # Read options parameter
  build_variant = options[:build_variant].downcase
  project_config = options[:project_config]
  release_title = (options[:release_title].nil? ? "#{project_config["project_name"]} #{build_variant.upcase} (Build #{get_build_number})" : options[:release_title])
  hipchat_channel = project_config["hipchat_channel"]

  smf_notify_via_mail(
    build_variant: build_variant,
    release_title: release_title,
    send_to_autors: true,
    success: true
    )

  if hipchat_channel
    hipchat_channel = URI.escape(hipchat_channel)
    smf_notify_via_hipchat(
      build_variant: build_variant,
      release_title: release_title,
      project_config: project_config,
      hipchat_channel: hipchat_channel
      )
  end
end

######################################
### smf_handle_pod_publish_success ###
######################################

# options: build_variant (String), project_config (Hash), framework_config (Hash), release_title (String) [optional]

desc "Handle the success by sending email to the authors and post to the hipchat channel"
private_lane :smf_handle_pod_publish_success do |options|

  # Read options parameter
  build_variant = options[:build_variant].downcase
  project_config = options[:project_config]
  framework_config = options[:framework_config]

  current_version = read_podspec(path: framework_config["podsepc_path"])["version"]
  release_title = (options[:release_title].nil? ? "#{project_config["project_name"]} #{current_version})" : options[:release_title])

  smf_handle_success(
        build_variant: build_variant,
        release_title: release_title,
        project_config: project_config
    )
end


############################
### smf_handle_exception ###
############################

# options: exception (exception), build_variant (String), project_config (Hash), release_title (String) [optional]

desc "Handle the exception by sending email to the authors"
private_lane :smf_handle_exception do |options|

  UI.important("Handle the build job exception")

  # Read options parameter
  exception = options[:exception]
  build_variant = options[:build_variant].downcase
  project_config = options[:project_config]
  release_title = (options[:release_title].nil? ? "#{project_config["project_name"]} #{build_variant.upcase} (Build #{get_build_number})" : options[:release_title])

  unless ENV["SMF_CHANGELOG"].nil?
    # Collect the changelog (again) in case the build job failed before the former changelog collecting
    smf_collect_changelog(
      build_variant: build_variant
    )
  end

  smf_notify_via_mail(
    build_variant: build_variant,
    release_title: release_title,
    send_to_autors: true,
    success: false,
    exception_message: exception
  )
end


########################################
### smf_handle_pod_publish_exception ###
########################################

# options: build_variant (String), project_config (Hash), framework_config (Hash), exception (Exception), release_title (String) [optional]

desc "Handle the success by sending email to the authors and post to the hipchat channel"
private_lane :smf_handle_pod_publish_exception do |options|

  # Read options parameter
  build_variant = options[:build_variant].downcase
  project_config = options[:project_config]
  framework_config = options[:framework_config]
  exception = options[:exception]

  current_version = read_podspec(path: framework_config["podsepc_path"])["version"]
  release_title = (options[:release_title].nil? ? "#{project_config["project_name"]} #{current_version})" : options[:release_title])

  smf_handle_exception(
    build_variant: build_variant,
    release_title: release_title,
    project_config: project_config,
    exception: exception,
    )
end


#######################
### smf_archive_ipa ###
#######################

# options: build_variants_config (Hash), project_config (Hash), build_variant (String)

desc "Build the project based on the build type."
private_lane :smf_archive_ipa do |options|

  UI.important("Build a new version")

  # Read options parameter
  project_name = options[:project_config]["project_name"]
  build_variant = options[:build_variant].downcase
  build_variant_config = options[:build_variants_config]["targets"][build_variant]

  extensions_suffixes = options[:extensions_suffixes]

  # Set the Apple Team ID
  team_id build_variant_config["team_id"]

  unlock_keychain(path: "login.keychain", password: ENV["LOGIN"])

  is_adhoc_build = build_variant.include? "adhoc"

  sigh(
    adhoc: is_adhoc_build,
    skip_certificate_verification:true,
    app_identifier: build_variant_config["bundle_identifier"]
    )

  if extensions_suffixes
    for extension_suffix in extensions_suffixes do
      sigh(
        adhoc: is_adhoc_build,
        skip_certificate_verification:true,
        app_identifier: "#{build_variant_config["bundle_identifier"]}.#{extension_suffix}"
    )
    end
  end

  unlock_keychain(path: "jenkins.keychain", password: ENV["JENKINS"])

  gym(
    clean: true,
    workspace: "#{project_name}.xcworkspace",
    scheme: build_variant_config["scheme"],
    configuration: 'Release',
    codesigning_identity: build_variant_config["code_signing_identity"],
    output_directory: "build",
    archive_path:"build/",
    output_name: build_variant_config["scheme"]
    )
end

#############################
### smf_collect_changelog ###
#############################

# options: build_variant (String)

desc "Collect git commit messages and author mail adresses into a changelog and store them as environmental varibles."
private_lane :smf_collect_changelog do |options|

  UI.important("collect commits back to the last tag")

  # Read options parameter
  build_variant = options[:build_variant].downcase

  if ["alpha"].any? { |item| build_variant.downcase.include?(item) }
    ENV["SMF_CHANGELOG"] =  changelog_from_git_commits(include_merges: false, pretty: '- (%an) %s')
    ENV["SMF_CHANGELOG_EMAILS"] = changelog_from_git_commits( include_merges: false, pretty: '%ae')
  elsif ["patch", "minor", "major", "current"].any? { |item| build_variant.downcase.include?(item) }
    ENV["SMF_CHANGELOG"] =  changelog_from_git_commits(tag_match_pattern: "releases*",include_merges: false, pretty: '- (%an) %s')
    ENV["SMF_CHANGELOG_EMAILS"] = changelog_from_git_commits(tag_match_pattern: "releases*",include_merges: false, pretty: '%ae')
  else
    ENV["SMF_CHANGELOG"] =  changelog_from_git_commits(tag_match_pattern: "*#{build_variant}*",include_merges: false, pretty: '- (%an) %s')
    ENV["SMF_CHANGELOG_EMAILS"] = changelog_from_git_commits(tag_match_pattern: "*#{build_variant}*",include_merges: false, pretty: '%ae')
  end

end


############################
### smf_test_pod_project ###
############################

# options: project_config (Hash), framework_config (Hash)

desc "Performs the unit tests of a project."
private_lane :smf_test_pod_project do |options|

  UI.important("Perform the unit tests")

  # Read options parameter
  project_config = options[:project_config]
  framework_config = options[:framework_config]

    scan(
      workspace: "#{project_config["project_name"]}.xcworkspace",
      scheme: "#{framework_config["scheme"]}",
      clean: false,
      custom_report_file_name: "report.xml"
    )

end

#######################################
### smf_disable_former_hockey_entry ###
#######################################

# options: build_variant_config (Hash), build_variant (String)

desc "Disable the downlaod of the former app version on HockeyApp - does not apply for Alpha builds."
private_lane :smf_disable_former_hockey_entry do |options|

  # Read options parameter
  build_variant = options[:build_variant].downcase
  build_variant_config = options[:build_variant_config]
  build_variants_contains_whitelist = options[:build_variants_contains_whitelist]

  # Disable the download of the former non Alpha app on Hockey App
    if (!build_variants_contains_whitelist) || (build_variants_contains_whitelist.any? { |whitelist_item| build_variant.include?(whitelist_item) })
    if (Actions.lane_context[Actions::SharedValues::HOCKEY_BUILD_INFORMATION]['id'] > 1)
      previous_version_id  = Actions.lane_context[Actions::SharedValues::HOCKEY_BUILD_INFORMATION]['id'] - 1

      UI.important("HERE IS THE ID OF THE Current VERSION #{Actions.lane_context[Actions::SharedValues::HOCKEY_BUILD_INFORMATION]['id']}")
      UI.important("HERE IS THE ID OF THE Previous VERSION #{previous_version_id}")

      disable_hockey_download(
        api_token: ENV["HOCKEYAPP_API_TOKEN"],
        public_identifier: build_variant_config["hockeyapp_id"],
        version_id: "#{previous_version_id}"
        )
    end
  end
end


##############################
### smf_generate_meta_json ###
##############################

# options: branch (String), build_variant (String) and build_variants_contains_whitelist (String) [optional]

desc "Create and push the metaJSON files - applys only for Alpha builds."
private_lane :smf_generate_meta_json do |options|

  # Read options parameter
  branch = options[:branch]
  build_variant = options[:build_variant].downcase
  project_name = options[:project_config]["project_name"]
  build_variants_contains_whitelist = options[:build_variants_contains_whitelist]

  if (!build_variants_contains_whitelist) || (build_variants_contains_whitelist.any? { |whitelist_item| build_variant.include?(whitelist_item) })
    desc "Create the meta JSON files"
    # Fetch the MetaJSON scripts repo
    sh "git clone git@github.com:smartmobilefactory/SMF-iOS-MetaJSON.git"
    # Create and commit the MetaJSON files
    sh "cd .. && fastlane/SMF-iOS-MetaJSON/scripts/update-and-push-meta-jsons.sh \"#{branch}\" \"#{project_name}\" || true"
    # Remove the MetaJSON scripts repo
    sh "rm -rf SMF-iOS-MetaJSON"
  end

end


###############################
### smf_push_generated_code ###
###############################

# options: branch (String)

desc "Commit and push generated code"
private_lane :smf_push_generated_code do |options|

  UI.important("Commit and push generated code")
    # Read options parameter
  branch = options[:branch]

  sh "git add ../Generated/ || true"
  sh "git commit -m \"Update generated code\" || true"

  push_to_git_remote(
    remote: 'origin',
    local_branch: branch,
    remote_branch: branch,
    force: false,
    tags: true
    )

end


#############################
### smf_push_build_number ###
#############################

# options: project_config (Hash), branch (String)

desc "Commit and push the build number."
private_lane :smf_push_build_number do |options|

  # Read options parameter
  project_name = options[:project_config]["project_name"]
  branch = options[:branch]

  UI.important("Increment Build Version Code")
  version = get_build_number(xcodeproj: "#{project_name}.xcodeproj")
  puts version

  commit_version_bump(
    xcodeproj: "#{project_name}.xcodeproj",
    message: "Increment build number to #{version}",
    force: true
    )
    
  push_to_git_remote(
    remote: 'origin',
    local_branch: branch,
    remote_branch: branch,
    force: false,
    tags: true
  )

end

#######################
### smf_add_git_tag ###
#######################

# options: project_config (Hash), tag_prefix (String), tag_suffix (String) [optional], branch (String) [optional]

desc "Tag the current git commit."
private_lane :smf_add_git_tag do |options|

  # Read options parameter
  project_name = options[:project_config]["project_name"]
  tag_prefix = (options[:tag_prefix].nil? ? "" : options[:tag_prefix])
  tag_suffix = (options[:tag_suffix].nil? ? "" : options[:tag_suffix])
  branch = options[:branch]

  UI.important("Tag the current commit")
  version = get_build_number(xcodeproj: "#{project_name}.xcodeproj")

  # Tag the current commit
  if git_tag_exists(tag: tag_prefix+version+tag_suffix)
    UI.message("Git tag already existed")
  else
    add_git_tag(
      tag: tag_prefix+version+tag_suffix
      )
  end
    
  push_to_git_remote(
    remote: 'origin',
    local_branch: branch,
    remote_branch: branch,
    force: false,
    tags: true
  )

end

##############################
### smf_notify_via_hipchat ###
##############################

# options: project_config (Hash), release_title (String), channel (String)

desc "Post to a HipChat room if the build was successful"
private_lane :smf_notify_via_hipchat do |options|

  # Read options parameter
  project_name = options[:project_config]["project_name"]
  release_title = options[:release_title]
  hipchat_channel = options[:hipchat_channel]

  hipchat(
    message:"<table><tr><td><strong>ðŸŽ‰ Successfully released #{release_title} ðŸŽ‰</strong></td></tr><tr></tr><tr><td><pre>#{ENV["SMF_CHANGELOG"]}</pre></td></tr></table>",
    channel: hipchat_channel,
    success: true,
    api_token: ENV["HIPCHAT_API_TOKEN"],
    notify_room: true,
    version: "2",
    message_format: "html",
    include_html_header: false,
    from: "#{project_name} iOS CI"
  )

end


###########################
### smf_notify_via_mail ###
###########################

# options: release_title (String), authors_emails (String), success (Boolean), exception_message (String) [Optional]

desc "Send emails to all collaborators who worked on the project since the last build to inform about successfully or failing build jobs."
private_lane :smf_notify_via_mail do |options|

  # Read options parameter
  release_title = options[:release_title]
  send_to_autors = options[:send_to_autors]
  success = options[:success]
  exception_message = options[:exception_message]

  authors_emails = []
  if (send_to_autors) && (ENV["SMF_CHANGELOG_EMAILS"])
    authors_emails = ENV["SMF_CHANGELOG_EMAILS"].split(" ").uniq.delete_if{|e| e == "git-checkout@smartmobilefactory.com"}
  end

  case success
  when true
    subject = "Successfully released #{release_title}"
    message = "ðŸŽ‰ #{release_title} is available ðŸŽ‰"
    app_link = Actions.lane_context[Actions::SharedValues::HOCKEY_DOWNLOAD_LINK]
  else
    subject = "Failed to build #{release_title}"
    message = "ðŸ˜¢ Failed to build and release #{release_title} ðŸ˜¢"
    message << "<p style='
                border: 1px solid #D8D8D8;
                padding: 5px;
                border-radius: 5px;
                font-family: Arial;
                font-size: 11px;
                text-transform: uppercase;
                background-color: rgb(255, 249, 242);
                color: rgb(211, 0, 0);
                text-align: center;' >#{exception_message} <p>"
    app_link = ""
  end

  authors_emails.each do |receiver|
    mailgun(
      subject: subject,
      postmaster:"postmaster@mailgun.smfhq.com",
      apikey: ENV["MAILGUN_KEY"],
      to: receiver,
      success: success,
      message: message,
      app_link: app_link,
      ci_build_link: ENV["BUILD_URL"],
      template_path: "/Users/smf/jenkins/template_mail.erb"
      )
  end

end


################################
### smf_upload_ipa_to_hockey ###
################################

# options: project_config (Hash)

desc "Clean, build and release the app on HockeyApp"
private_lane :smf_upload_ipa_to_hockey do |options|

  UI.important("Upload a new build to HockeyApp")

  # Read options parameter
  hockey_app_id = options[:build_variant_config]["hockeyapp_id"]

  puts "IPA: "+lane_context[SharedValues::IPA_OUTPUT_PATH]+"".green

  hockey(
    api_token: ENV["HOCKEYAPP_API_TOKEN"],
    ipa: lane_context[SharedValues::IPA_OUTPUT_PATH],
    notify: "0",
    notes: ENV["SMF_CHANGELOG"],
    public_identifier: hockey_app_id
    )

  clean_build_artifacts

end
