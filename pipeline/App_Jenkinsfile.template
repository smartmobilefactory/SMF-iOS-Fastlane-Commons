#!/usr/bin/env groovy
//
// Automatically generated. Do not edit.
//

//////////////////////
/// Regex Patterns ///
//////////////////////

_ok_to_test_pattern = /^(ok to test)\s*$/
_merge_trigger_pattern = /^[release|merge]+ ([\w-_.]+)\s*$/
_project_name_pattern = /([\w-_.\/]+)\/PR-[\d]+$/

/////////////////////////
/// Static Parameters ///
/////////////////////////

_agent_label = 'pipeline'
_build_variants = __BUILD_VARIANTS__

////////////////////////////
/// Declarative Pipeline ///
////////////////////////////

pipeline {

    agent { label _agent_label }

    options {
        // Skip default SCM checkout to speed the process when the git source is not needed (stages 'Check Conditions' and 'Merge Pull Request').
        skipDefaultCheckout()
    }

    environment {
        // The following environment variables cannot be overriden in stages.
        // Fastlane Localisation
        LC_ALL = 'en_US.UTF-8'
        LANG = 'en_US.UTF-8'
        // Infrastructure and tools
        GITHUB_TOKEN = credentials('GITHUB_API_TOKEN_SMF_ACCOUNT')
        DANGER_GITHUB_API_TOKEN = credentials('DANGER_GITHUB_API_TOKEN')
        HOCKEYAPP_API_TOKEN = credentials('HOCKEYAPP_API_TOKEN')
        // Keychain Access
        LOGIN = credentials('iOS_NODES_LOGIN_KEYCHAIN')
        JENKINS = credentials('iOS_NODES_JENKINS_KEYCHAIN')
        SMF_HOCKEYAPP_ONE_SIGNAL_BASIC_AUTH = credentials('ONESIGNAL_SMF_API_KEY')
        SMF_SLACK_URL_IDENTIFIER = credentials('SMF_SLACK_URL_IDENTIFIER')
        SENTRY_API_ACCESS_TOKEN = credentials('SENTRY_API_ACCESS_TOKEN')
        SMF_PHRASEAPP_ACCESS_TOKEN = credentials('PHRASEAPP_API_ACCESS_TOKEN')
    }

    parameters {
        // Use generated project buld variants (aka. build targets of the related project).
        choice(choices: _build_variants, description: 'Target', name: 'build_variant')
    }

    triggers {
        issueCommentTrigger("${_ok_to_test_pattern}|${_merge_trigger_pattern}")
    }

    stages {
        stage('Check Conditions') {
            steps {
                script {
                    // Get the current build's cause and to understand how it has been triggered.
                    def triggerCause = currentBuild.rawBuild.getCause(org.jenkinsci.plugins.pipeline.github.trigger.IssueCommentCause)
                    if (triggerCause) {
                        if (triggerCause.comment ==~ _ok_to_test_pattern) {
                            // Build triggered by a "ok to test" command.
                            env.CHECK_PR = "true"
                        } else if (triggerCause.comment ==~ _merge_trigger_pattern) {
                            // Build triggered by a merge command.
                            env.MERGE_COMMAND = triggerCause.comment
                        } else {
                            fail('ABORTED', "Command '${triggerCause.comment}' not matching trigger pattern: ${triggerCause.triggerPattern}")
                        }
                    } else {
                        // Build was started with a push on a branch.
                        // The current build is linked to a PR when the CHANGE_ID variable is set.
                        env.CHECK_PR = "true"
                    }
                }
            }
        }

        stage('Setup and generate files') {
            when { expression { env.CHANGE_ID != null && env.MERGE_COMMAND == null } }

            steps {
                checkout scm
                
                script {
                    // Delete the gemfile.lock if it exists
                    sh '''#!/bin/bash -l
                        cd fastlane
                        bundle install
                        cd ..
                        if rm fastlane/Gemfile.lock 2> /dev/null; then
                            echo "Removed Gemfile.lock"
                        fi
                        '''
                }
            }
        }

        stage('Check Pull Request') {
            // CHANGE_ID is set only for pull requests, so it is safe to access the pullRequest global variable.
            // CHECK_PR is set only for pushes on a branch with an active PR or with the command 'ok to test'.
            when { expression { env.CHANGE_ID != null && env.CHECK_PR == "true" } }

            steps {
                // Git Checkout to access the source files.
                checkout scm

                script {
                    def project_path = downstream_project_path()
                    wrap([$class: 'AnsiColorBuildWrapper', 'colorMapName': 'XTerm']) {
                        sh '''#!/bin/bash -l
                            cd fastlane
                            bundle install
                            bundle exec fastlane check_pr
                            '''
                    }
                }
            }
        }

        stage('Merge Pull Request') {
            // MERGE_COMMAND is set only when a merge command has triggered the current build.
            when { expression { env.CHANGE_ID != null && env.MERGE_COMMAND != null } }

            steps {
                script {
                    if (pullRequest.mergeable == false) {
                        fail('FAILURE', "Pull Request '${env.JOB_NAME}' is not mergeable.")
                    }

                    def build_variant = build_variant()
                    def project_path = downstream_project_path()

                    if (_build_variants.contains(build_variant) == false) {
                        def build_variants_description =  _build_variants.join("\n - ")
                        fail('ABORTED', "Invalid build variant '${build_variant}'.\nAvailable targets (case sensitive):\n - ${build_variants_description}")
                    }

                    // Merge the related pull request.
                    pullRequest.merge(commitTitle: "${env.JOB_BASE_NAME} merge", commitMessage: "Merge triggered for ${env.JOB_NAME} with command: ${env.MERGE_COMMAND}", sha: "${pullRequest.head}", mergeMethod: "merge")

                    // Start a downstream job with the specified branch and build variant.
                    build job: "${project_path}/${pullRequest.base}", parameters: [string(name: 'build_variant', value: "${build_variant}")], wait: false
                }
            }
        }

        stage('Build and Release') {
            // Since the basic-branch-build-strategies plugin has been installed, the jobs are only automatically triggered for the PR jobs (regex: 'PR-[0-9]+').
            // Doing so the 'Build and Release' stage is only executed when the job has been manually triggered via the Jenkins UI OR through a release command on a upstream PR job.
            // In any case could the current build be linked to a PR and therefore the CHANGE_ID variable is never set.
            when { expression { env.CHANGE_ID == null } }

            steps {
                // Git Checkout to access the source files.
                checkout scm

                wrap([$class: 'AnsiColorBuildWrapper', 'colorMapName': 'XTerm']) {
                    sh '''#!/bin/bash -l
                        cd fastlane
                        bundle install
                        bundle exec fastlane deploy_app build_variant:${build_variant} branch:${BRANCH_NAME}
                        '''
                }
            }
        }
    }
}

/////////////////////////
/// Utility Functions ///
/////////////////////////

/// Property 'build_variant' (aka. target) from the merge command (eg. the issue comment on GitHub).
def build_variant() {
    def merge_command_matcher = (env.MERGE_COMMAND =~ _merge_trigger_pattern)
    if (merge_command_matcher.matches() == false) {
        fail('ABORTED', "Invalid merge command '${env.MERGE_COMMAND}' does not match pattern: ${_merge_trigger_pattern}")
    }

    def build_variant = merge_command_matcher.group(1)
    return build_variant
}

/// Path on Jenkins of the downstream project.
///
/// The downstream project must be used to build a new release on a specific branch (not a pull request based one).
/// Example: 'Selfie/Selfie-Android' from the env.JOB_NAME 'Selfie/Selfie-Android/PR-31'
def downstream_project_path() {
    def project_path_matcher = ("${env.JOB_NAME}" =~ _project_name_pattern)
    if (project_path_matcher.matches() == false) {
        fail('FAILURE', "Project name '${env.JOB_NAME}' not matching pattern: ${_project_name_pattern}")
    }

    def project_path = project_path_matcher.group(1)
    return project_path
}

/// Set the result of the current build, log the error message and throw the an error.
///
/// Parameters:
/// - result: Valid status keyword with color code: 'ABORTED' - gray, 'FAILURE' - red.
/// - message: Error description.
def fail(result, description) {
    def message = "Pipeline ${result}: ${description}"
    // Update the current build result.
    currentBuild.result = result
    // Write the error message as comment on GitHub.
    pullRequest?.comment(message)
    // Create/throw a pipeline error.
    error(message)
}